# File: run_mom.sh.in
# Purpose: input for BASH script for running MOM5 models
# Author: Vassili Kitsios, modified from previous script of Pavel Sakov
# Date: 2020

set -euxEo pipefail
ulimit -c unlimited
export F_UFMTENDIAN=big

module list

WDIR=WDIR_INPUT
SAVE_EXP_DIR=SAVE_EXP_DIR_INPUT
CYCLE_ID=CYCLE_ID_INPUT
months=MONTHS_INPUT
mem=MEM1_INPUT
DT=DT_INPUT

PYTHON=PYTHON_INPUT
POSTPROCESSING_SRCDIR=POSTPROCESSING_SRCDIR_INPUT
ZARR_PATH=ZARR_PATH_INPUT
ZARR_CONFIG_FILE=zarr_specs_CAFE-f6.json
ZARR_OUTPUT_PATH=${SAVE_EXP_DIR}/ZARR
POSTPROCESSING_LOGDIR=../postprocessing_logs
CHECK_CONFIG_FILE=check_specs.json

JULDAY=`cat ${WDIR}/JULDAY.txt | head -1`

memstr=`printf "mem%03d" $mem`
cd ${WDIR}/$memstr

#====================================================================
# Check previous failures have been cleaned up
if [ -f "MOM.failed" ]; then
	exit
fi

if [ -f "NETCDF_COMBINE.failed" ]; then
	exit
fi

#====================================================================
if [ ! -f "MOM.done" ]; then
	# Build namelist
	set +e
	rm -f input.nml
	cat ${WDIR}/MOM/input.nml \
		| sed "s/.*dt_ocean.*/dt_ocean = ${DT}/"\
	       	| sed "s/.*dt_cpld.*/dt_cpld = ${DT}/"\
	       	| sed "s/.*dt_atmos.*/dt_atmos = ${DT}/"\
		| sed "s/INPUT_MONTHS/months = ${months}/"\
	       	> input.nml

	# Launch MOM job
	MOM_COMMAND_INPUT ./EXEC  2>&1 | tee mom-${DT}.out

	# Checck for successful completion
	set -e
        mom_complete_flag=`tail -n1 mom-${DT}.out | grep 'MPP_STACK high water mark=' | grep '0' | wc -l`
        if (( mom_complete_flag == 1 )) ; then
                echo "full success"

                # backup input files
                mkdir -p INPUT_SAVE
                files=`ls INPUT/*.res.nc*`
                for file in $files ; do
                        if [ -f "$file" ] ; then
                                mv $file INPUT_SAVE
                        fi
                done
                mv -f RESTART/* INPUT
                rm -f INPUT/????????.??0000.*.nc
                rm -f INPUT/????????.??0000.*.res

                touch MOM.done

	else
		echo "mom-${CYCLE_ID}-MOM (member $mem) failed, bailing out"
		touch MOM.failed
		exit
	fi
fi

#====================================================================
if [ -f "MOM.done" ]; then
	if [ ! -f "NETCDF_COMBINE.done" ]; then
        	./merge.sh
	        if  stat -t *.nc.* >/dev/null 2>&1 ; then
        	        touch NETCDF_COMBINE.failed
                	exit
	        else
        	        touch NETCDF_COMBINE.done
        	fi
        fi
fi

#====================================================================
# Launch Regridding scripts
export PATH="${PYTHON}:${PYTHON}/bin:${PATH}"
export PYTHONPATH="${PYTHONPATH}:${ZARR_PATH}"
mkdir -p $POSTPROCESSING_LOGDIR
if [ -f "NETCDF_COMBINE.done" ]; then
        if [ ! -f "${POSTPROCESSING_LOGDIR}/REGRID_${memstr}.done" ]; then
                ${POSTPROCESSING_SRCDIR}/convert_forecast_to_isobaric_Gadi.sh ./
                touch ${POSTPROCESSING_LOGDIR}/REGRID_${memstr}.done

		#-------------------------------------------
		# How can we detect if this step failed??
		#-------------------------------------------
        fi
fi

#====================================================================
# Set up striping of ZARR output directory
STRIPE_COUNT=60
if [ ! -d $ZARR_OUTPUT_PATH ]; then 
        mkdir $ZARR_OUTPUT_PATH
        lfs setstripe --stripe-count $STRIPE_COUNT --stripe-size 1M $ZARR_OUTPUT_PATH
elif (( `lfs getstripe -d $ZARR_OUTPUT_PATH | grep -oP "stripe_count:\s+\K[0-9]+"` != $STRIPE_COUNT )); then
        echo "$ZARR_OUTPUT_PATH exists but is not striped correctly"
        exit
fi

#====================================================================
# Launch zarring scripts
OUTPUT_DIR=${ZARR_OUTPUT_PATH}/${memstr}
if [ -f "${POSTPROCESSING_LOGDIR}/REGRID_${memstr}.done" ]; then
        if [ ! -f "${POSTPROCESSING_LOGDIR}/ZARR_${memstr}.done" ]; then
                cp -v ${POSTPROCESSING_SRCDIR}/$ZARR_CONFIG_FILE .

                # Create zarr collections on node local storage -----
                jobfs_path=${PBS_JOBFS}/ZARR
                python ${POSTPROCESSING_SRCDIR}/convert_forecast_to_zarr.py ${WDIR} ${jobfs_path} -r "all" -e $mem -c $ZARR_CONFIG_FILE --zip_output \
                    > ${POSTPROCESSING_LOGDIR}/ZARR_${memstr}.progress 2>&1

                # Copy zips to zarr_path -----
                echo "Copying collections to ${OUTPUT_DIR}..." >>${POSTPROCESSING_LOGDIR}/ZARR_${memstr}.progress
		STRIPE_COUNT=30
		if [ ! -d $OUTPUT_DIR ]; then
		        mkdir $OUTPUT_DIR
		        lfs setstripe --stripe-count $STRIPE_COUNT --stripe-size 1M $OUTPUT_DIR
		elif (( `lfs getstripe -d $OUTPUT_DIR | grep -oP "stripe_count:\s+\K[0-9]+"` != $STRIPE_COUNT )); then
		        echo "$OUTPUT_DIR exists but is not striped correctly"
		        exit
		fi
                cp ${jobfs_path}/*.zarr.zip $OUTPUT_DIR >>${POSTPROCESSING_LOGDIR}/ZARR_${memstr}.progress 2>&1
		
		chmod 775 $OUTPUT_DIR/*.zip

                touch ${POSTPROCESSING_LOGDIR}/ZARR_${memstr}.done

		#-------------------------------------------
		# How can we detect if this step failed??
		#-------------------------------------------
        fi
fi


#====================================================================
# Launch checking scripts
if [ -f "${POSTPROCESSING_LOGDIR}/ZARR_${memstr}.done" ]; then
        if [ ! -f "${POSTPROCESSING_LOGDIR}/CHECK_${memstr}.done" ]; then
                cp -v ${POSTPROCESSING_SRCDIR}/$CHECK_CONFIG_FILE .
                export PP_ZARR_PATH=$OUTPUT_DIR
                export PP_CONFIG_PATH=$CHECK_CONFIG_FILE
		pytest -v ${POSTPROCESSING_SRCDIR}/tests/test_zarr.py > ${POSTPROCESSING_LOGDIR}/CHECK_${memstr}.progress 2>&1
                status=$?
                if (( "$status" == "0" )); then
                	touch ${POSTPROCESSING_LOGDIR}/CHECK_${memstr}.done
		else
                	touch ${POSTPROCESSING_LOGDIR}/CHECK_${memstr}.failed
                fi
        fi
fi


#====================================================================
# Check if all zarring completed
num_complete=`ls ${POSTPROCESSING_LOGDIR}/CHECK_*.done | wc -l`
if (( num_complete == ENSSIZE )) ; then
        paths_to_merge=( `ls -d ${ZARR_OUTPUT_PATH}/mem???` )
        realms_as_separate_jobs=( atmos_daily atmos_isobaric_daily ocean_month ocean_bgc_month ) # all realms not specified here will be lumped into single additional job
        exclude_realms=( ) # realms not to merge (e.g. if already done)
        all_realms=$(python ${POSTPROCESSING_SRCDIR}/parse_realms.py < "$ZARR_CONFIG_FILE")
        remaining_realms=( `echo ${all_realms[@]} ${realms_as_separate_jobs[@]} ${exclude_realms[@]} | tr ' ' '\n' | sort | uniq -u` )
	cp -v ${POSTPROCESSING_SRCDIR}/merge_zarr_members.py .
        for realm in ${realms_as_separate_jobs[@]}; do
                if [ ! -f "${POSTPROCESSING_LOGDIR}/MERGE_${realm}.done" ]; then
                        qsub -v "paths_to_merge=$(echo ${paths_to_merge[@]}), zarr_path=${ZARR_OUTPUT_PATH}, realms=$realm, ZARR_CONFIG_FILE=$ZARR_CONFIG_FILE, LOG_DIR=$POSTPROCESSING_LOGDIR" ${POSTPROCESSING_SRCDIR}/run_merge_members_Gadi.sh
                fi
        done
        if [ ! -f "${POSTPROCESSING_LOGDIR}/MERGE_${remaining_realms%% *}.done" ]; then
                qsub -v "paths_to_merge=$(echo ${paths_to_merge[@]}), zarr_path=${ZARR_OUTPUT_PATH}, realms=$(echo ${remaining_realms[@]}), ZARR_CONFIG_FILE=$ZARR_CONFIG_FILE, LOG_DIR=$POSTPROCESSING_LOGDIR" ${POSTPROCESSING_SRCDIR}/run_merge_members_Gadi.sh
        fi
		#-------------------------------------------
		# How can we detect if this step failed??
		#-------------------------------------------
fi


#====================================================================
# EOF
#====================================================================
